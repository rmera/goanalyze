'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/goanalyze/docs/gorama/','title':"Ramachandran plot of PyMOL selections",'content':"The following command\ngorama sele Will produce a Ramachandran plot for the selection sele. In this case, the different points in the plot will be colored, from blue to red, according to the place of the sequence corresponding to each residue plotted (i.e. the mark corresponding to the first residue will be blue, the last, red)\nYou can also get a plot for several selections with:\ngorama sele1, sele2, sele3 ... (the \u0026lsquo;\u0026hellip;\u0026rsquo; indicates that you can add more selections).\nIn this case, the marks in the plot will be colored according to the selection to which they belong. The marks belonging to the first selection will be blue, progressing through grteen, up to the ones belonging to the last selection which will be red. The figure shows an example with two selections.\n"});index.add({'id':1,'href':'/goanalyze/docs/gomd/shape/','title':"Shape indicators",'content':"goAnalyze can obtain indicators of the global shape of a PyMOL selection. The percentage of planarity and elongation are derived from the properties of the moment of inertia tensor, based on the work by Taylor et al., .(1983), J Mol Graph, 1, 30\nTo obtain the percentage of planarity and elongation for a selection in a single frame, use:\ngoshape sele Where sele is the name of the selection.\nIf you want to follow the evolution of the shape of one or more selections along a trajectory, you need to use gomd. Use:\ngomd planarity, sel1, sel2 ... or\ngomd elongation, sel1, sel2 ... To plot the respective properties for the selections of interest, as in the figure\n"});index.add({'id':2,'href':'/goanalyze/docs/goreduce/','title':"Adding hydrogens to PyMOL selections",'content':"goAnalyze uses Reduce to add hydrogens to a (proteic) PyMOL selection. Since a binary is provided for Reduce, installing it is nothing more than downloading it, renaming the binary to \u0026ldquo;reduce\u0026rdquo; and ensuring that it is in the PATH.\nIt\u0026rsquo;s use is very simple. If you have the Reduce program installed and the binary is named \u0026ldquo;reduce\u0026rdquo;, you only have to type the following, in the PyMOL command line:\ngoreduce sele This will protonate the selection sele. The protonated structure will be loaded as a new PyMOL object named sele_H (or whateveryourselectionameis_H)\nThe figure shows a goAnalyze/Reduce protonated selection in PyMOL, together with an unprotonated one.\nRemember to cite Reduce if you use this functionality in you paper!\n"});index.add({'id':3,'href':'/goanalyze/docs/goopt/','title':"Geometry optimizations",'content':"goAnalyze uses the xtb from the Grimme Group to optimize PyMOL objects or selections. The xtb program is open source, and easy-to-install binaries are provided.\nBasic optimization: The command:\ngoopt sele Will optimize the geometry of the selection sele The optimized structure will be written to a new object called \u0026ldquo;sele_opt\u0026rdquo; (or whatevertheselectionamewas_opt\u0026rdquo;)\nA bit more advanced The previous is a very fast semiempirical model (GFN0-xTB). You can request a cheaper, but still accurate force-field (GFNFF) calculation with:\ngoopt sele, -quality=medium or, for a more costly, but also more accurate semiempirical method (GFN2-xTB):\ngoopt sele, -quality=vhigh You can also indicate the charge and multiplicity of your selection as, for example:\ngoopt sele, -charge=1, -multi=2 In many cases you don\u0026rsquo;t want to optimize your molecule in vacuo. By default, goAnalyze uses the dielectric solvent for water, but you can choose to use the dielectric of a protein (which will actually be modelled as chloroform, with a dielectric constant of 5, close to the dielectric of 4 normally used for the inside of proteins) or none at all\ngoopt sele, -solvent=protein Finally, you can give a second selection containing atoms to be kept fixed during the optimization. If tha name of that selection was selfixed the command would be:\ngoopt sele fixed=selfixed Optimizing protein subsequences Consider that you want to optimize a selection, a subsequence of your protein, including only the residues, say, from, 5 to 10. You could ask goopt to optimize that selection, but, when selecting, you have broken two covalent bonds (the peptidic bonds from 4 to 5 and that from 10 to 11, unless the 10 residue is the C terminal). Thus, the optimized result will probably not be what you want. Instead, you can use goAnalyze to cap the missing bonds with hydrogens. The command\ngocap selection Will cap the needed broken bonds (it makes a fair attempt at guessing if a given residue is N- or C- terminal) and produce a new object, selection__cap (or whateverthename__cap). In addition, a selection called \u0026ldquo;tofix\u0026rdquo; will be created, which contains atoms at the edges of the subsequence which you might want to fix during the optimization. So, calling:\ngoopt selection__cap fixed=tofix Will probably do what you want.\nBut what if you want to optimize several subsequences? You can just use gocap several times. You\u0026rsquo;ll get several \u0026ldquo;something__cap\u0026rdquo; objects, and the \u0026ldquo;tofix\u0026rdquo; selection will be updated to include the atoms to be fixed for all subsequences. Before calling goopt, you need to put all the capped objects into one selection. For example:\nselect alltogether__cap, sele1__cap, sele2__cap, sele3__cap Then:\ngoopt alltogether__cap, fixed=tofix It is important that you keep the \u0026ldquo;__cap\u0026rdquo; part in the final, aggregated selection name.\nThe example shows an optimized subsequence for a protein (in magenta) superimposed with the non-optimized protein (in gray).\nReferences. If you use the methods mentioned above in your research, we ask you to cite the appropiate references:\n GFN2-xTB (The \u0026ldquo;vhigh\u0026rdquo; method in goAnalyze). GFN0-xTB (The \u0026ldquo;high\u0026rdquo; method). GFNFF (The \u0026ldquo;medium\u0026rdquo;, and default, goAnalyze method). A review on the methods  "});index.add({'id':4,'href':'/goanalyze/docs/gomd/distances/','title':"Distances",'content':"You can plot the distances between pairs of selections along a trajectory. If a selection has more than one atom, its center of mass will be used. If the masses for one or more atoms can\u0026rsquo;t be obtained, the geometric center will be used (a warning is printer in this case).\nThe command is:\ngomd distances, sele1, sele2, sele3, sele4 ... Which will plot the distances between the selections sele1 and sele2 and between sele3 and sele4. Note that you need to give an even number of selections.\n"});index.add({'id':5,'href':'/goanalyze/docs/gomd/','title':"MD trajectory analysis",'content':"Apart from the structural analysis functions, goAnalyze includes the gomd command, which provides a small suite of a trajectory analysis functions.\nAll the functions are called as follows:\ngomd funcion, selection1, selection2 ... Mind the commas!\nYou can also specify if you want to analyse only 1 every X frames, by doing:\ngomd function, selection1, selection2 ... skip=X Where X is a integer larger than 0. Note that, despite the name, you are not quite giving the frames to skip, but, rather, every how many frames to read. Thus, skip=1 (the default) will read every 1 frames, i.e. will read all of them.\nSome of the available functions take several selections as arguments, some take only one.\n"});index.add({'id':6,'href':'/goanalyze/docs/gomd/ramachandran/','title':"Ramachandran plots",'content':"The gomodel MD Ramachandran plots work similarly to the isolated-structure ones. The main differences are:\n Only one selection is accepted The point in the plot are colored by the frame of the trajectory to which they correspond  You will also notice that the appearance of the plot is different in both cases. This is because only the MD trajectory Ramachandran plot uses the Python Matplotlib library, while the single-structure one uses Go and Gonum to produce the image.\nThe command:\ngomd ramachandran, sele will create a Ramachandran plot of the selection sele along the whole trajectory. If you want only one residue, remember to include the one before and the one after it in the selection, as those atoms are needed to calculate the dihedrals. Example:\n"});index.add({'id':7,'href':'/goanalyze/docs/gomd/rmsd/','title':"RMSD",'content':"The RMSD of several selections against references for each of them can be plotted. The general way to do it is:\ngomd rmsd, ref1, sel1, ref2, sel2 ... Where ref1 is the references state for sel1 and so on. In the most common case, you simply want to use the first frame of the same selection as a reference. In that case, simply do:\ngomd rmsd, sel1, sel1, sel2, sel2 ... Which will take the first frame of sel1 as a reference for the RMSD of sel1, and so on. Note that rmsd doesn\u0026rsquo;t perform any previous superposition.\n"});index.add({'id':8,'href':'/goanalyze/docs/gomd/rmsf/','title':"RMSF",'content':"You can easily plot the RMSF for all atoms in a selection, over a trajectory by using this command:\ngomd rmsf, sele Where sele is the name of your selection.\nNote that only one selection is accepted here. If you give more, the rest will be ignored. A common application of this function is to obtain the RMSF for the alpha carbons of a protein during a trajectory, as in the example:\n"});index.add({'id':9,'href':'/goanalyze/docs/gomd/super/','title':"Superimposing a trajectory",'content':"You can superimpose a whole trajectory to a given reference. You need 3 selections:\nThe reference For which the first state will be taken.\nThe target selection This selection needs to have the same number of atoms as the reference. For each frame of this selection gomd will calculate the superposition to the first frame of the reference, thus obtaining rotation and translation matrices.\nThe \u0026ldquo;moved\u0026rdquo; selection For each frame, the rotation + translation matrices obtained with the corresponding frame of the target will be applied to this selection. It needs to have the same amount of frames as the target selection.\nAn example Say you want to translate/rotate your protein trajectory to match a reference, but you want to only consider the alpha carbons to calculate the superposition (of course, you want to translate/rotate your whole protein, not only the alpha carbons!).\nFirst, create a selection with only the alpha carbons of the reference:\nselect alpha-ref, refProtein and name CA Now create a selection with the alpha carbons of the trajectory\nselect alpha-traj, trajectory and name CA Now alpha-ref is your reference selection, alpha-traj is your target selection and trajectory (the object containing your trajectory) is the moved selection. You are ready now to call gomd:\ngomd super, alpha-ref, alpha-traj, trajectory A new, superimposed trajectory will appear, named \u0026ldquo;trajectory_sup\u0026rdquo;\nNote that this can use a lot of memory if your trajectory is large!\n"});index.add({'id':10,'href':'/goanalyze/docs/cheatsheet/','title':" goAnalyze Cheat Sheet",'content':" All arguments go separated by commas Optional arguments are shown between brackets, with their default value.  Single structures Ramachandran plot gorama sele1, sele2, ... Add hydrogens to a (proteic) selection goreduce sele Geometry optimization goopt sele [fixed=fixsele] [quality=medium] [solvent=water] [charge=0] [multi=1] Trajectories All trajectory functions accept a \u0026ldquo;skip=N\u0026rdquo; paramenter that causes gomd to analyze every N frames. skip=1 (the default) reads every 1 frame, i.e. all frames.\nDistances gomd distances, sele1, sele2, sele3, sele4 ... (the numbr of selections must be even!)\nRamachandran Plot gomd ramachandran, sele RMSD gomd rmsd, sel1, sel1, sel2, sel2 ... Uses the first frame from sel1 as a reference for all frames in sel1, and so on.\nRMSF gomd rmsf, selection Superimposing gomd super, ref_sele, target_sele, moved_sele "});index.add({'id':11,'href':'/goanalyze/docs/download/','title':"Download goAnalyze!",'content':"goAnalyze is open source, but we also provide easy-to-install binaries for Linux. (the installer assumes Bash).\nMac is a work in progress. Binaries are provided, but we haven\u0026rsquo;t been able to test them, or the instalation procedure, as we are not Mac users and we don\u0026rsquo;t own an Apple machine. Windows support has the same issue, with the additional complication of the OS being more different from Linux than Mac.\nThe current version is v0.1.0\nThe binaries from the release page are:\n Get the binary package for Linux Get the binary package for Mac (the install script might not work)  Dependencies Apart from PyMOL itself, goAnalyze has few dependencies. In general, only the matplotlib and numpy Python libraries. Geometry optimizations uses xtb program. Hydrogen addition to proteins use the Reduce program.\n"});index.add({'id':12,'href':'/goanalyze/docs/','title':"Docs",'content':""});})();